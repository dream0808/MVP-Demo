#  操作系统

## OS的运行机制和体系

### 运行机制

- **两种指令**
  - 特权指令（不允许用户程序使用）
  - 非特权指令
- **两种处理机状态**（用程序状态寄存器（PSW）标志位标识）
  - 核心态（管态）
  - 用户态（目态）
- **两种程序**
  - 内核程序  --> 操作系统
  - 用户程序

### 操作系统内核

- **时钟管理**

  实现计时功能

- **中断处理**

  负责实现中断机制

- **原语**

  - 是一种特殊的程序
  - 处于操作系统底层，是最接近硬件的部分
  - 这种程序的运行具有原子性 —— 运行只能一气呵成，不可中断
  - 运行时间较短，调用频繁

- **对系统资源进行管理的功能**

  - 进程管理
  - 处理器管理
  - 设备管理

### 操作系统体系结构

- **大内核**
  - 将操作系统的主要功能模块都作为系统内核，运行在核心态
  - 优点：高性能
  - 缺点：内核代码庞大，结构混乱，难以维护
- **微内核**
  - 只把最基本的功能保留在内核
  - 优点：内核功能少，结构清晰，方便维护
  - 缺点：需要频繁的在核心态和用户态之间切换，性能低

## 中断和异常

### 中断的作用

让操作系统内核强行夺回CPU的控制权
使CPU从用户态变为内核态

### 中断的分类

- **内中断（也称异常、例外）**
  - 陷阱、陷入(trap)
  - 故障(fault)
  - 终止(abort)
- **外中断（也称”中断“）**
  - 时钟中断
  - I/O中断请求

### 中断机制的基本实现原理

- 检查中断信号
  - 内中断：CPU在执行指令时会检查是否有异常发生
  - 外中断：每个指令周期末尾，CPU都会检查是否有外中断信号需要处理
- 找到相应的中断处理程序
  - 通过”中断向量表“实现

## 进程

### 概念

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

### 组成

- **PCB**
  - 进程描述信息
  - 进程控制和管理信息
  - 资源分配清单
  - 处理机相关信息
- **程序段**
  - 程序的代码（指令序列）
- **数据段**
  - 运行过程中产生的各种数据（如：程序中定义的变量）

### 特征

- 动态性

  <font color='red'>进程的最基本特性</font>

- 并发性

- 独立性

- 异步性

  进程是能独立运行、<font color='red'>独立获得资源、独立接受调度的基本单位</font>

- 结构性

  各进程以不可预知的速度向前推进，可能导致运行结果的不确定性

## 系统调用

### 什么是系统调用？

操作系统对应用程序程序员提供的接口

### 系统调用与库函数的区别

- 有的库函数是对系统调用的进一步封装
- 有的库函数没有使用系统调用

### 小例子：为什么系统调用是必须的？

Word和WPS同时打印

### 什么功能要用系统调用实现？

**凡是与共享资源有关的操作、会直接影响到其他进程的操作，就一定需要操作系统介入，就需要通过系统调用来实现**

-  设备管理
- 文件管理
- 进程控制
- 进程通信
- 内存管理

### 系统调用的过程

- 传参
- <font color='red'>陷入指令/Trap/访管</font>
- 由操作系统内核程序处理系统调用请求
- 返回应用程序

## 处理机调度

### 1.基本概念

**按某种算法选择一个进程将处理机分配给它**

### 2.三个层次

- **高级调度（作业调度）**

按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程

- **中级调度（内存调度）**

按照某种规则，从挂起队列中选择合适的进程将其数据调回内存

- **低级调度（进程调度）**

按照某种规则，从就绪队列中选择一个进程为其分配处理机

### 3.三层调度的联系、对比

- **高级调度**

外存 ---> 内存（面向作业）

发生频率：最低

- **中级调度**

外存 ---> 内存（面向进程）

发生频率：中等

- **低级调度**

内存 ---> CPU

发生频率：最高

### 4.补充知识

**4.1、为减轻系统负载，提高资源利用率，暂时不执行的进程会被调到外存从而变为“挂起态”**

**4.2、七状态模型：在五状态模型的基础上加入了“就绪挂起"和“阻塞挂起“两种状态**

## 进程调度

### 时机

#### 什么时候需要进程调度

- **主动放弃**

进程正常终止

运行过程中发生异常而终止

主动阻塞（如等待I/O)

- **被动放弃**

分给进程的时间片用完

有更紧急的事情需要处理（如I/O中断）

有更高优先级的进程进入就绪队列

#### 什么时候不能进行进程调度？

在处理中断的过程中

进程在操作系统内核程序临界区中

原子操作过程中（原语）

### 切换与过程

#### 狭义的“调度"和“切换"的区别

#### 切换过程

对原来运行进程各种数据的保存

对新的进程各种数据的恢复

#### 重要结论

进程调度、切换是有代价的，并不是调度越频繁，并发度就越高

### 方式

#### 非剥夺调度方式（非抢占式）

只能由当前运行的进程主动放弃CPU

#### 剥夺调度方式（抢占式）

可由操作系统剥夺当前进程的CPU使用权

## 调度算法的评价指标

### CPU利用率

<font color='red'>利用率</font>=忙碌的时间/总时间

### 系统吞吐量

<font color='red'>系统吞吐量</font>=总共完成了多少道作业/总共花了多少时间

### 周转时间

<font color='red'>周转时间</font>=作业完成时间-作业提交时间

<font color='red'>平均周转时间</font>=各作业周准之和/作业数

<font color='red'>带权周转时间</font>=作业周转时间/作业实际运行的时间

<font color='red'>平均带权周转时间</font>=各作业带权周转时间之和/作业数

### 等待时间

进程/作业等待被服务的时间之和

平均等待时间即各个进程/作业等待时间的平均值

### 响应时间

从用户提交请求到首次产生响应所用的时间

## FCFS、SJF、HRRF调度算法

| 算法    | 可抢占？                                                     | 优点                                                 | 缺点                                                 | 考虑到等待时间&<br/>运行时间 | 会导致饥饿？ |
| :------ | :----------------------------------------------------------- | :--------------------------------------------------- | :--------------------------------------------------- | :--------------------------- | :----------- |
| FCFS    | 非抢占式                                                     | 公平：实现简单                                       | 对短作业不利                                         | 等待时间√运行时间 ×          | 不会         |
| SJF/SPF | 默认为非抢占式，也有SJF的抢占式版本最短剩余时间优先算法(SRTN) | “最短的”平均等待/周转时间                            | 对长作业不利，可能导致饥饿；难以做到真正的短作业优先 | 等待时间×运行时间√           | 会           |
| HRRF    | 非抢占式                                                     | 上述两种算法的权衡折中，综合考虑的等待时间和运行时间 |                                                      | 等待时间√运行时间√           | 不会         |

**注：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但**
**是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算**
**法一般适合用于<font color='red'>早期的批处理系统</font>。当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的**
**角色。而适合用于<font color='red'>交互式系统</font>的调度算法将在下个小节介绍**

## 同步、互斥

### 进程同步

并发性带来了异步性，有时需要通过进程同步解决这种异步问题。
有的进程之间需要相互配合地完成工作，各进程的工作推进需要遵循一定的先后顺序。

### 进程互斥

- **进入区**

检查是否可进入临界区，若可进入，需要“上锁”

- **临界区**

访问临界资源的那段代码

- **退出区**

负责“解锁”

- **剩余区**

其余代码部分

### 需要遵循的原则

- **空闲让进**

临界区空闲时，应允许一个进程访问

- **忙则等待**

临界区正在被访问时，其他试图访问的进程需要等待

- **有限等待**

要在有限时间内进入临界区，保证不会饥饿

- **让权等待**

进不了临界区的进程，要释放处理机，防止忙等

## 进程互斥的软件实现方法

- **单标志法**

在进入区只做”检查“，不”上锁“

在退出区把临界区的使用权转交给另一个进程（相当于在退出区即给另一进程“解锁”，又给自己“上锁”）

主要问题：不遵循“空闲让进”原则

- **双标志先检查**

在进入区“检查”后“上锁”，退出区“解锁”

主要问题：不遵循“忙则等待”原则

- **双标志后检查**

在进入区先“加锁”后检查，检查区“解锁”

主要问题：不遵循“空闲让进、有限等待”原则，可能导致“饥饿”

- **Peterson算法**

在进入区“主动争取—主动谦让—检查对方是否想进、己方是否谦让”

主要问题：不遵循“让权等待”原则，会发生“忙等”

## 进程互斥的硬件实现方法

- **中断屏蔽方法**

使用“开/关中断”指令实现

优点：简单高效

缺点：只适用于单处理机；只适用于操作系统内核进程

- **TestAndSet（TS指令/TSL指令）**

old记录是否已被上锁，再将lock设为true，检查临界区是否已被上锁（若已上锁，则重复循环前几步）

优点：实现简单；适用于多处理机环境；

缺点：不满足“让权等待”

- **Swap指令（XCHG指令）**

逻辑上同TSL

## 信号量机制

- **整型信号量**

用一个整数型变量作为信号量，数值表示某种资源数

整型信号量与普通整型变量的区别：对信号量只能执行初始化、P、V三种操作

整型信号量存在的问题：<font color='red'>不满足让权等待原则</font>

- **<font color='red'>记录型信号量</font>**

S.value 表示某种资源数，S.L指向等待该资源的队列

P操作中，一定是先S.value--，之后可能需要执行block原语

V操作中，一定是先S.value++，之后可能需要执行wakeup原语

注意：要能够自己推断在什么条件下需要执行block或wakeup

可以用记录型信号量实现系统资源的“申请”和“释放”

可以用记录型信号量实现进程互斥、进程同步

- **实现进程互斥**

分析问题，确定临界区

设置互斥信号量，初值为1

临界区之前对信号量执行P操作

临界区之后对信号量执行V操作

- **实现进程同步**

分析问题，找出哪里需要实现“一前一后”的同步关系

设置同步信号量，初始值为0

在“前操作”之后执行V操作

在“后操作”之前执行P操作

- **实现进程的前驱关系**

分析问题，画出前驱图，把每一对前驱关系都看成一个同步问题

为每一对前驱关系设置同步信号量，初值为0

在每个“前操作”之后执行V操作

在每个“后操作”之前执行P操作

## 管程

### 为什么要引入管程

解决信号量机制编程麻烦、易出错的问题

### 组成

共享数据结构

对数据结构初始化的语句

一组用来访问数据结构的过程（函数）

### 基本特征

<font color='red'>各外部进程/线程只能通过管程提供的特定“入口”才能访问</font>

<font color='red'>每次仅允许一个进程在管程内执行某个内部过程</font>

### 补充

各进程必须互斥访问管程的特性是由编译器实现的

可在管程中设置条件变量及等待/唤醒操作以解决同步问题

## 死锁的概念

### 什么是死锁

各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进

### 死锁、饥饿、死循环的区别

|        | 区别                                                         | 共同点                                                 |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------ |
| 死锁   | 死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那<font color='red'>至少有两个或两个以上的进程同时发生死锁</font>。另外，发生死锁的进程一定处于阻塞态 | 都是进程无法顺利向前推进的现象（故意设计的死循环除外） |
| 饥饿   | <font color='red'>可能只有一个进程发生饥饿</font>。发生饥饿的进程既可能是阻塞态（如长期得不到需要的I/O设备），也可能是就绪态（长期得不到处理机） |                                                        |
| 死循环 | 可能只有一个进程发生死循环。死循环的进程可以上处理机运行（可以是运行态)，只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。<font color='red'>死锁和饥饿是管理者（操作系统）的问题，死循环是被管理者的问题。</font> |                                                        |

### 死锁产生的必要条件

- **互斥条件**

对必须互斥使用的资源的争抢才会导致死锁

- **不剥夺条件**

进程保持的资源只能主动释放，不可强行剥夺

- **请求和保持条件**

保持着某些资源不放的同时，请求别的资源

- **循环等待条件**

存在一种进程资源的循环等待链

循环等待未必死锁，死锁一定有循环等待

### 什么时候会发生死锁

对不可剥夺资源的不合理分配，可能导致死锁

### 死锁的处理策略

- **预防死锁**

破坏死锁产生的四个必要条件

- **避免死锁**

避免系统进入不安全态（银行家算法）

- **死锁的检测与解除**

允许死锁发生，系统负责检测出死锁并解除

## 预防死锁

- **破坏互斥条件**

将临界资源改造为可共享使用的资源（如SPOOLing技术0）

缺点：可行性不高，很多时候无法破坏互斥条件

- **破坏不剥夺条件**

方案一：申请的资源得不到满足时，立即释放拥有的所有资源

方案二：申请的资源被其他进程占用时，由操作系统协助剥夺（考虑优先级）

缺点：实现复杂；剥夺资源可能导致部分工作失效；反复申请和释放导致系统开销大；可能导致饥饿

- **破坏请求和保持条件**

运行前分配好所有需要的资源，之后一直保持

缺点：资源利用率低；可能导致饥饿

- **破坏循环等待条件**

给资源编号，必须按编号从小到大的顺序申请资源

缺点：不方便增加新设备；会导致资源浪费；用户编程麻烦

## 死锁的检测和解除

1. **如何检测**

   - **数据结构**：<font color='red'>资源分配图</font>

     - 两种节点

       1.进程节点

       2.资源节点

     - 两种边

       1.进程节点 -->资源节点

       2.资源节点 -->进程节点

   - **<font color='red'>死锁检测算法</font>**

     - <font color='red'>依次消除与不阻塞进程相连的边，直到无边可消</font>
     - 注：所谓不阻塞进程是指其申请的资源数还足够的进程
     - 死锁定理：若资源分配图是不可完全简化的，说明发生了死锁

2. **如何解除**

   - 资源剥夺法
   - 撤销进程法（终止进程法）
   - 进程回退法

## 内存的基础知识

### <font color='red'>什么是内存，有何作用</font>

存储单元、内存地址的概念和联系

按字节编址 vs 按字编址

### 进程运行的基本原理

#### 指令的工作原理

操作码 + 若干参数（可能包含地址参数）

#### <font color='red'>逻辑地址（相对地址） vs 物理地址（绝对地址）</font>

#### <font color='red'>从写程序到程序运行</font>

- **编辑源代码文件**

- **编译**

  由源代码文件生成目标模块（高级语言“翻译”为机器语言）

- **链接**

  由目标模块生成装入模块，链接后形成完整的逻辑地址

- **装入**

  将装入模块装入内存，装入后形成物理地址

#### 三种链接方式

- **静态链接**

  装入前链接成一个完整装入模块

- **装入时动态链接**

  运行前装入边链接

- **运行时动态链接**

  运行时需要目标模块才能装入并链接

#### <font color='red'>三种装入方式</font>

- **绝对装入**

  编译时产生绝对地址

- **可重定位装入**

  装入时将逻辑地址转换为物理地址

- **<font color='red'>动态运行时装入</font>**

  运行时将逻辑地址转换为物理地址，需设置重定位寄存器

## 内存管理的概念

### 内存空间的分配与回收

### 内存空间的扩充（实现虚拟性）

### 地址转换

- **操作系统负责实现逻辑地址到物理地址的转换**
- **三种方式**
  - 绝对装入：编译器负责地址转换（单道程序阶段，无操作系统）
  - <font color='red'>可重定位装入（静态重定位）</font>：装入程序负责地址转换（早期多道批处理阶段）
  - <font color='red'>动态运行时装入（动态重定位）</font>：运行时才进行地址转换（现代操作系统）

### 存储保护

- 保证各进程在自己的内存空间内运行，不会越界访问
- 两种方式
  - 设置上下限寄存器
  - 利用重定位寄存器、界地址寄存器进行判断

## 覆盖与交换

### 覆盖技术

- 一个固定区
  - 存放最活跃的程序段
  - <font color='red'>固定区中的程序段在运行过程中不会调入调出</font>
- 若干覆盖区
  - 不可能同时被访问程序段可共享一个覆盖区
  - <font color='red'>覆盖区中的程序段在运行过程中会根据需要调入调出</font>
- 必须由程序员声明覆盖结构，操作系统完成自动覆盖
- 缺点：对用户不透明，增加了用户编程负担

### 交换技术

内存紧张时，换出某些进程以腾出内存空间，再换入某些进程

磁盘分为文件区和对换区，换出的进程放在对换区

### 覆盖与交换的区别

覆盖是在同一个程序或进程中的

交换是在不同进程（或作业）之间的

## 连续分配管理

- **单一连续分配**

  只支持单道程序，内存分为系统区和用户区，用户程序在用户区

  <font color='red'>无外部碎片，有内部碎片</font>

- **固定分区分配**

  支持多道程序，内存用户空间分为若干个固定大小的分区，每个分区只能装一道作业

  <font color='red'>无外部碎片，有内部碎片</font>

  两种分区方式

  - 分区大小相等
  - 分区大小不等

- **动态分区分配**

  支持多道程序，在进程装入内存时，根据进程的大小动态地建立分区

  <font color='red'>无内部碎片，有外部碎片</font>

  外部碎片可用“紧凑“技术来解决

  回收内存分区时，可能遇到四种情况

  - 回收区之后有相邻的空闲分区
  - 回收区之前有相邻的空闲分区
  - 回收区前、后都有相邻的空闲分区
  - 回收区前、后都没有相邻的空闲分区

## 四种动态分区分配算法

| 算法     | <font color='red'>算法思想</font>                            | 分区排列顺序                                 | 优点                                                         | 缺点                                                         |
| :------- | ------------------------------------------------------------ | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 首次适应 | <font color='red'>从头到尾找适合的分区</font>                | 空闲分区以地址递增次序排列                   | 综合看性能最好。**算法开销小**，回收分区后一般不需要对空闲分区队列重新排序 |                                                              |
| 最佳适应 | <font color='red'>优先使用更小的分区，以保留更多大分区</font> | 空闲分区以容量递增次序排列                   | 会有更多的大分区被保留下来，更能满足大进程需求               | 会产生很多太小的、难以利用的碎片；**算法开销大**，回收分区后可能需要对空闲分区队列重新排序 |
| 最坏适应 | <font color='red'>优先使用更大的分区，以防止产生太小的不可用的碎片</font> | 空闲分区以容量递减次序排列                   | 可以减少难以利用的小碎片                                     | 大分区容易被用完，不利于大进程：**算法开销大**(原因同上)     |
| 临近适应 | <font color='red'>由首次适应演变而来，每次从上次查找结束位置开始查找</font> | 空闲分区以地址递增次序排列(可排列成循环链表) | 不用每次都从低地址的小分区开始检索。**算法开销小（**原因同首次适应算法) | 会使高地址的大分区也被用完                                   |

## 基本分页存储管理的基本概念

基本分页存储管理的思想：把进程分页，各个页面可离散地放到各个的内存块中

### <font color='red'>重要概念</font>

“页框、页帧、内存块、物理块”  VS  “页、页面”

“页框号、页帧号、内存块号、物理块号”VS“页号、页面号”

### 如何实现地址转换

1. 计算出逻辑地址对应的页号
2. 找到对应页面在内存中的存放位置
3. 算出逻辑地址对应的页内偏移量
4. 物理地址=页面始址+页内偏移量

### <font color='red'>页号、页内偏移量的计算</font>

页号=逻辑地址/页面大小；页内偏移量=逻辑地址%页面大小

或根据逻辑地址结构计算，逻辑地址=【页号P,页内偏移量W】

### <font color='red'>页表</font>

页表记录进程页面和实际存放的内存块之间的对应关系

一个进程对应一张页表，进程的每一页对应一个页表项，每个页表项由“页号"和“块号"组成

每个页表项的长度是相同的，页号是“隐含"的

## 基本地址变换机构

### 页表寄存器的作用

存放页表起始地址

存放页表长度

### <font color='red'>地址变换过程</font>

1.根据逻辑地址算出页号、页内偏移量

2.页号的合法性检查（与页表长度对比）

3.若页号合法，再根据页表起始地址、页号找到对应页表项（第一次访问内存）

4.根据页表项中记录的内存块号、页内偏移量 得到最终的物理地址

5.访问物理内存对应的内存单元（第二次访问内存）

### 其他小细节

页内偏移量位数与页面大小之间的关系（要能用其中一个条件推出另一个条件）

页式管理中地址是一维的

实际应用中，通常使一个页框恰好能放入整数个页表项

为了方便找到页表项，页表一般是放在连续的内存块中的

## 快表变换机构

|                        | 地址变换过程                                                 | 访问一个逻辑地址的访存次数                                   |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 基本地址变换机构       | ①算页号、页内偏移量<br>②检查页号合法性<br>③查页表，找到页面存放的内存块号<br>④根据内存块号与页内偏移量得到物理地址<br>⑤访问目标内存单元 | <font color='red'>两次访存</font>                            |
| 具有快表的地址变换机构 | ①算页号、页内偏移量<br>②检查页号合法性<br>③<font color='red'>查快表</font>。若命中，即可知道页面存放的内存块号，可直接进行⑤；若未命中则进行④<br>④查页表，找到页面存放的内存块号，<font color='red'>并且将页表项复制到快表中</font><br>⑤根据内存块号与页内偏移量得到物理地址<br>⑥访问目标内存单元 | 快表<font color='red'>命中</font>，只需<font color='red'>一次访存</font></br><br>快表<font color='red'>未命中</font>，需要<font color='red'>两次访存</font> |

## 两级页表

### 单级页表存在的问题

所有页表项必须连续存放，页表过大时需要很大的连续空间

在一段时间内并非所有页面都用得到，因此没必要让整个页表常驻内存

### 两级页表

将长长的页表再分页

逻辑地址结构：（一级页号，二级页号，页内偏移量）

注意几个术语：页目录表/外层页表顶级页表

### 如何实现地址变换

①按照地址结构将逻辑地址拆分成三部分

②从PCB中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置

③根据二级页号查表，找到最终想访问的内存块号

④结合页内偏移量得到物理地址

### 几个细节

多级页表中，各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级

多级页表的访存次数（假设没有快表机构）一N级页表访问一个逻辑地址需要N+1次访存

## 基本分段存储管理

### 分段

将地址空间按照程序自身的逻辑关系划分为若干个段，每段从0开始编址

每个段在内存中占据连续空间，但各段之间可以不相邻

逻辑地址结构：（段号，段内地址）

### 段表

记录逻辑段到实际存储地址的映射关系

每个段对应一个段表项。各段表项长度相同，由段号（隐含）、段长、基址组成

### 地址变换

1.由逻辑地址得到段号、段内地址
2.段号与段表寄存器中的段长度比较，检查是否越界
3.由段表始址、段号找到对应段表项
4.根据段表中记录的段长，检查段内地址是否越界
5.由段表中的“基址+段内地址"得到最终的物理地址
6.访问目标单元

### 分段 VS 分页

分页对用户不可见，分段对用户可见
分页的地址空间是一维的，分段的地址空间是二维的
分段更容易实现信息的共享和保护（纯代码/可重入代码可以共享）
分页（单级页表）、分段访问一个逻辑地址都需要两次访存，分段存储中也可以引入快表机构

## 分页、分段的优缺点分析

|          | 优点                                                         | 缺点                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 分页管理 | 内存空间利用率高，<font color='red'>不会产生外部碎片</font>，只会有少量的页内碎片 | 不方便按照逻辑模块实现信息的共享和保护                       |
| 分段管理 | 很方便按照逻辑模块实现信息的共享和保护                       | 如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理<font color='red'>会产生外部碎片</font> |

## 段页式管理

### 分段+分页

将地址空间按照程序自身的逻辑关系划分为若干个段，在将各段分为大小相等的页面

将内存空间分为与页面大小相等的一个个内存块，系统以块为单位为进程分配内存

逻辑地址结构：(段号，页号，页内偏移量)

### 段表、页表

每个段对应一个段表项。各段表项长度相同，由段号（隐含）、页表长度、页表存放地址组成

每个页对应一个页表项。各页表项长度相同，由页号（隐含）、页面存放的内存块号组成

### 地址变换

1.由逻辑地址得到段号、页号、页内偏移量
2.段号与段表寄存器中的段长度比较，检查是否越界
3.由段表始址、段号找到对应段表项
4.根据段表中记录的页表长度，检查页号是否越界
5.由段表中的页表地址、页号得到查询页表，找到相应页表项
6.由页面存放的内存块号、页内偏移量得到最终的物理地址
7.访问目标单元

### 访问一个逻辑地址所需访存次数

第一次 一一 查段表、第二次 一一 查页表、第三次 一一 访问目标单元

可引入快表机构，以段号和页号为关键字查询快表，即可直接找到最终的目标页面存放位置。引入快表后仅需一次访存

## 虚拟内存的基本概念

### 传统存储管理方式的特征、缺点

- 一次性：作业数据必须一次全部调入内存
- 驻留性：作业数据在整个运行期间都会常驻内存

### 局部性原理

- 时间局部性：现在访问的指令、数据在不久后很可能会被再次访问
- 空间局部性：现在访问的内存单元周围的内存空间，很可能在不久后会被访问
- 高速缓存技术：使用频繁的数据放到更高速的存储器中

### 虚拟内存的定义和特征

定义：程序不需全部装入即可运行，运行时根据需要动态调入数据，若内存不够，还需换出一些数据

特征：

- 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
- 对换性：无需在作业运行时一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
- 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。

### 如何实现虚拟内存技术

访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存（请求调页功能）

内存空间不够时，将内存中暂时用不到的信息换出到外存（页面置换功能）

**虚拟内存的实现**

- 请求分页存储管理
- 请求分段存储管理
- 请求段页式存储管理

## 请求分页管理方式

### 页表机制

在基本分页的基础上增加了几个表项

1. 状态位：表示页面是否已在内存中
2. 访问字段：记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考
3. 修改位：表示页面调入内存后是否被修改过，只有修改过的页面才需在置换时写回外存
4. 外存地址：页面在外存中存放的位置

### 缺页中断机构

找到页表项后检查页面是否已在内存，若没在内存，产生缺页中断

缺页中断处理中，需要将目标页面调入内存，有必要时还要换出页面

缺页中断属于内中断，属于内中断中的“故障”，即可能被系统修复的异常

一条指令在执行过程中可能产生多次缺页中断

### 地址变换机构(重点关注与基本分页不同的地方)

找到页表项是需要检查页面是否在内存中

若页面不再内存中，需要请求调页

若内存空间不够，还需换出页面

页面调入内存后，需要修改相应页表项

## 页面置换算法

|                          | 算法规则                                                     | 优缺点                                           |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------ |
| OPT（最佳置换）          | 优先淘汰最长时间内不会被访问的页面                           | 缺页率最小，性能最好；但无法实现                 |
| FIFO（先进先出）         | 优先淘汰最先进入内存的页面                                   | 实现简单；但性能很差，可能出现Belady异常         |
| LRU（最少使用）          | 优先淘汰最近最久没访问的页面                                 | 性能很好；但需要硬件支持，算法开销大             |
| CLOCK（NRU）             | 循环扫描各页面<br/>第一轮淘汰访问位=0的，并将扫描过的页面访问位改为1。若第一轮没选中，则进行第二轮扫描。 | 实现简单，算法开销小：但未考虑页面是否被修改过。 |
| 改进型CLOCK（改进型NRU） | 若用（访问位，修改位）的形式表述，则<br/>第一轮：淘汰(0,0)<br/>第二轮：淘汰(0,1)，并将扫描过的页面访问位都置为0<br/>第三轮：淘汰(0,0)<br/>第四轮：淘汰(0,1) | 算法开销较小，性能也不错                         |

## 页面分配策略

### 驻留集

指请求分页存储管理中给进程分配的内存块的集合

### 页面分配、置换策略

固定分配 VS 可变分配：区别在于进程运行期间驻留集大小是否可变

局部置换 VS 全局置换：区别在于发生缺页时是否只能从进程自己的页面中选择一个换出

固定分配局部置换：进程运行前就分配一定数量物理块，缺页时只能换出进程自己的某一页

可变分配全局置换：只要缺页就分配新物理块，可能来自空闲物理块，也可能需换出别的进程页面

可变分配局部置换：频繁缺页的进程，多分配一些物理块；缺页率很低的进程，回收一些物理块。直到缺页率合适

### 何时调入页面

预调页策略：一般用于进程运行前
请求调页策略：进程运行时，发现缺页再调页

### 从何处调页

对换区 —— 采用连续存储方式，速度更快；文件区 —— 采用离散存储方式，速度更慢。
对换区足够大：运行将数据从文件区复制到对换区，之后所有的页面调入、调出都是在内存与对换区之间进行
对换区不够大：不会修改的数据每次都从文件区调入；会修改的数据调出到对换区，需要时再从对换区调入
UNIX方式：第一次使用的页面都从文件区调入；调出的页面都写回对换区，再次使用时从对换区调入

### 抖动（颠簸）现象

页面频繁换入换出的现象。主要原因是分配给进程的物理块不够

### 工作集

在某段时间间隔里，进程实际访问页面的集合。驻留集大小一般不能小于工作集大小

## I/O设备的基本概念与分类

### 什么是I/O设备

将数据Input/Output(输入/输出)计算机的外部设备

### 按使用特性分类

- 人机交互类外部设备
- 存储设备
- 网络通信设备

### 按传输速率分类

- 低速设备
- 中速设备
- 高速设备

### 按信息交换的单位分类

- 块设备（传输快，可寻址）
- 字符设备（传输慢，不可寻址，常采用中断驱动方式）

## I/O控制器

### 主要功能

- 接受和识别CPU发出的命令（要有控制寄存器）
- 向CPU报告设备的状态（要有状态寄存器）
- 数据交换（要有数据寄存器，暂存输入/输出的数据）
- 地址识别（由I/O逻辑实现）

### 组成

- CPU与控制器之间的接口（实现控制器与CPU之间的通信）
- I/O逻辑（负责识别CPU发出的命令，并向设备发出命令)
- 控制器与设备之间的接口（实现控制器与设备之间的通信）

### 两种寄存器编址方式

- 内存映射I/O
  - 控制器中的寄存器与内存统一编制
  - 可以采用对内存进行操作的指令来对控制器进行操作
- 寄存器独立编制
  - 控制器中的寄存器独立编制
  - 需要设置专门的指令来操作控制器

## 假脱机技术/SPOOLing技术

### 脱机技术

外围控制机+更高速的设备 —— 磁带
作用：缓解设备与CPU的速度矛盾，实现预输入、缓输出

### 假脱机技术

又叫SPOOLing技术，用软件的方式模拟脱机技术
输入井和输出井 —— 模拟脱机输入/输出时的磁带
输入进程和输出进程 —— 模拟脱机输入/输出时的外围控制机
输入缓冲区和输出缓冲区 —— 内存中的缓冲区，输入、输出时的“中转站”

### 共享打印机

用SPOOLing技术将独占式的打印机“虚拟"成共享打印机

## 设备的分配与回收

### 应考虑的因素

- 固有属性

  独占设备、共享设备、虚拟设备(SPOOLing)

- 分配算法

  先来先服务、优先级高者优先、短任务优先等

- 安全性

  安全分配方式、不安全分配方式

### 静态分配与动态分配

- 静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源
- 动态分配：进程运行过程中动态申请设备资源

### 设备分配管理中的数据结构

- 设备控制表(DCT)

  每个设备对应一张DCT,关键字段：类型/标识符/状态/指向COCT的指针/等待队列指针

- 控制器控制表(COCT)

  每个控制器对应一张COCT,关键字段：状态/指向CHCT的指针/等待队列指针

- 通道控制表(CHCT)

  每个控制器对应一张CHCT,关键字段：状态/等待队列指针

- 系统设备表(SDT)

  记录整个系统中所有设备的情况，每个设备对应一个表目，关键字段：设备类型/标识符/DCT/驱动程序入口

### 设备分配的步骤

①根据进程请求的物理设备名查找SDT;②根据SDT找到DCT并分配设备；③根据DCT找到COCT并分配控制器；
④根据COCT找到CHCT并分配通道

注：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I/O设备进行数据传送

缺点：用户编程时必须使用“物理设备名"，若换了一个物理设备，则程序无法运行。若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待

### 设备分配步骤的改进

用户编程时使用逻辑设备名申请设备，操作系统负责实现从逻辑设备名到物理设备名的映射（通过LUT)

逻辑设备表的设置问题

- 整个系统只有一张LUT:各用户所用的逻辑设备名不允许重复
- 每个用户一张LUT:各个用户的逻辑设备名可重复

## 缓冲器管理

### 缓冲区的概念

一般利用内存作为缓冲区
缓解CPU与设备的速度矛盾、减少对CPU的中断频率、解决数据粒度不匹配的问题、提高CPU与引/O设备之间的并行性

### 单缓冲

设备一(T)一缓冲区一(M)一工作区一(C)一处理
处理一块数据平均耗时Max(C,T)+M
分析问题的初始状态：工作区满，缓冲区空

### 双缓冲

处理一块数据平均耗时Max(T,C+M)
分析问题的初始状态：工作区空，一个缓冲区满，另一个缓冲区空

### 循环缓冲

多个缓冲区链接成循环队列，in指针指向第一个空缓冲区，out指针指向第一个满缓冲区

### 缓冲池

- 三个队列：空缓冲队列、输入队列、输出队列
- 四种工作缓冲区
  - 用于收容输入数据的工作缓冲区、用于提取输入数据的工作缓冲区
  - 用于收容输出数据的工作缓冲区、用于提取输出数据的工作缓冲区

## 磁盘的结构

### 磁盘、磁道、扇区的概念

磁盘由表面涂有磁性物质的圆形盘片组成
每个盘片被划分为一个个磁道，每个磁道又划分为一个个扇区

### 如何在磁盘中读/写数据

磁头移动到目标位置，盘片旋转，对应扇区划过磁道才能完成读/写

### 盘面、柱面的概念

磁盘有多个盘片“摞”起来，每个盘片有两个盘面
所有盘面中相对位置相同的磁道组成柱面

### 磁盘的物理地址

(柱面号，盘面号，扇区号)

### 磁盘的分类

- 根据磁头是否可移动
  - 固定头磁盘（每个磁道有一个磁头）
  - 移动头磁盘（每个盘面只有一个磁头）
- 根据盘片是否可更换
  - 固定盘磁盘
  - 可换盘磁盘

## 磁盘调度算法

### 一次磁盘读/写操作需要的时间

寻找时间（寻道时间）：启动磁臂 **移动磁头所花的时间**（磁盘调度算法影响的指标）
延迟时间：将目标扇区转到磁头下面所花的时间
传输时间：读/写数据花费的时间

### 磁盘调度算法

- 先来先服务(FCFS)
  - 按访问请求到达的先后顺序进行处理
- 最短寻找时间优先(SSTF)
  - 每次都优先响应距离磁头最近的磁道访问请求
  - 贪心算法的思想，能保证眼前最优，但无法保证总的寻道时间最短
  - 缺点：可能导致饥饿
- 扫描算法（电梯算法、SCAN)
  - 只有磁头移动到最边缘的磁道时才可以改变磁头移动方向
  - 缺点：对各个位置磁道的响应频率不平均
- 循环扫描算法(C-SCAN)
  - 只有磁头朝某个方向移动时才会响应请求，移动到边缘后立即让磁头返回起点，返回途中不响应任何请求
- 低频考点（若题目中无特别说明，则SCAN就是LOOK,C-SCAN就是C-LOOK）
  - LOOK算法
    - SCAN算法的改进，只要在磁头移动方向上不再有请求，就立即改变磁头方问
  - C-LOOK算法
    - C-SCAN算法的改进，只要在磁头移动方向上不再有请求，就立即让磁头返回

## 减少延迟时间的方法

### 交替编号

具体做法：让编号相邻的扇区在物理上不相邻
原理：读取完一个扇区后需要一段时间处理才可以继续读入下一个扇区

### 错位命名

具体做法：让相邻盘面的扇区编号“错位”
原理：与“交替编号”"的原理相同。“错位命名法”可降低延迟时间

### 磁盘地址结构的设计

理解为什么要用（柱面号，盘面号，扇区号）的结构
理解为什么不用（盘面号，柱面号，扇区号）的结构
**原因：在读取地址连续的磁盘块时，前者更不需要移动磁头**

## 磁盘的管理

### 磁盘初始化

低级格式化 / 物理格式化：划分扇区
磁盘分区（C盘、D盘、E盘)
逻辑格式化：建立文件系统（建立根目录文件、建立用于存储空间管理的数据结构）

### 引导块

计算机启动时需要运行初始化程序（自举程序）来完成初始化
ROM中存放很小的自举装入程序
完整的自举程序存放在初始块（引导块）中

### 坏块的管理

简单的磁盘：逻辑格式化时将坏块标记出来
复杂的磁盘：磁盘控制器维护一个坏块链，并管理备用扇区

## 固态硬盘SSD

### 原理

基于闪存技术Flash Memory,属于电可擦除ROM,即EEPROM

### 组成

闪存翻译层 —— 负责翻译逻辑块号，找到对应页(Page)
存储介质：多个闪存芯片(Flash Chip) —— 每个芯片包含多个块(block) —— 每个块包含多个页(page)

### 读写性能特性

- 以页（page）为单位读/写 —— 相当于磁盘的“扇区”
- 以块（bock）为单位“擦除"，擦干净的块，其中的每页都可以写一次，读无限次
- 支持随机访问，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址
- 读快、写慢。要写的页如果有数据，则不能写入，需要将块内其他页全部复制到一个新的（擦除过的）块中，再写入新的页

### 与机械硬盘相比的特点

- SSD读写速度快，随机访问性能高，用电路控制访问位置；机械硬盘通过移动磁臂旋转磁盘控制访问位置，有寻道时间和旋转延迟
- SSD安静无噪音、耐摔抗震、能耗低、造价更贵
- <font color='red'>SSD的一个"块"被擦除次数过多（重复写同一个块）可能会坏掉，而机械硬盘的扇区不会因为写的次数太多而坏掉</font>

### 磨损均衡技术

- 思想：将“擦除”平均分布在各个块上，以提升使用寿命
- 动态磨损均衡 —— 写入数据时，优先选择累计擦除次数少的新闪存块
- 静态磨损均衡 —— SSD监测并自动进行数据分配、迁移，让老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务

## 初识文件管理

- 文件的定义：一组有意义的信息的集合
- 文件的属性：文件名、标识符、类型、位置、大小、保护信息.…
- 文件内部应该如何被组织起来（文件的逻辑结构）
- 文件之间应该如何被组织起来（目录结构）
- 操作系统应向上提供哪些功能(create、delete、open、close、read、write系统调用)
- 文件应如何存放在外存中（文件的物理结构）
- 操作系统如何管理外存中的空闲块（存储空间的管理）
- 操作系统需要提供的其他文件管理功能
  - 文件共享
  - 文件保护

### 有结构文件

- **顺序文件**
  - 串结构：记录顺序与关键字无关
  - 顺序结构：记录按关键字顺序排列
  - <font color='red'>可变长记录的顺序文件无法实现随机存取，定长记录可以</font>（可变长记录的顺序文件在每次查询时只能从头依次查找）
  - 定长记录、顺序结构的顺序文件可以快速检索（根据关键字快速找到记录）
  - 最大缺点：不方便增加/删除记录
- **索引文件**
  - 建立一张索引表，每个记录对应一个表项。各记录不用保持顺序，方便增加/删除记录
  - 索引表本身就是定长记录的顺序文件，一个索引表项就是一条定长记录，因此索引文件可支持随机存取
  - 若索引表按关键字顺序排列，则可支持快速检索
  - 解决了顺序文件不方便增/删记录的问题，同时让不定长记录的文件实现了随机存取。但索引表可能占用很多空间
- **索引顺序文件**
  - 将记录分组，每组对应一个索引表项
  - 检索记录时先顺序查索引表，找到分组，再顺序查找分组
  - 当记录过多时，可建立多级索引表

## 文件目录

### 文件目录的实现

一个文件对应一个FCB，一个FCB就是一个目录项，多个FCB组成文件目录
对目录的操作：搜索、创建文件、删除文件、显示文件、修改文件

### 目录结构

- **单级目录结构**

  一个系统只有一张目录表，不允许文件重名

- **两级目录结构**

  不同用户的文件可以重名，但不能对文件进行分类

- **多级（树形）目录结构**

  - 不同目录下的文件可以重名，可以对文件进行分类，不方便文件共享
  - 系统根据“文件路径"找到目标文件
  - 从根目录出发的路径是“绝对路径”("/照片/2015-08/自拍jpg")
  - 从"当前目录"出发的路径是“相对路径”("/照片/2015-08/自拍.jPg")

- **无环图目录结构**

  - 在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个有向无环图
  - 为共享结点设置一个共享计数器，计数器为0时才真正删除该结点

### 索引结点

- 除了文件名之外的所有信息都放到索引结点中，每个文件对应一个索引结点
- 目录项中只包含文件名、索引结点指针，因此每个目录项的长度大幅减小
- 由于目录项长度减小，因此每个磁盘块可以存放更多个目录项，因此检索文件时磁盘I/O的次数就少了很多



