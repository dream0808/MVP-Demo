# 算法

## 数学

### **1.计算1-1000之间的完数**

（完数：因子之和等于这个数，如6=1+2+3）

```java
   for(int i=1;i<=1000;++i) {
        int sum=0;
      for(int j=1;j<=i/2;j++) {
            if(i%j==0) {
                sum+=j;
            }
        }
        if(i==sum) {
            System.out.println(i);
        }
}
```

### 2.计算天数

```java
 SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd");
 Date date1= sdf1.parse("1949-10-1");
 Date date2= sdf1.parse("2022-01-01");

long start_time= date1.getTime();
long end_time = date2.getTime();

long days = (end_time-start_time)/24/1000/60/60;
 System.out.println(days);
```

## 打印图形

### **1.打印金字塔**

```java
    //内层循环控制行数
	//外层循环控制列数
	for(int i=1;i<=6;++i) {
		for(int j=1;j<=6-i;++j) {
			System.out.print(" ");
		}
		//控制星号
		for(int k=1;k<=i*2-1;++k) {
			System.out.print("*");
		}
		System.out.println();
	}
```

### **2.打印杨辉三角**

```java
	int[][] yangHui=new int[10][];
  for(int i=0;i<yangHui.length;++i) {
		yangHui[i]=new int[i+1];
		
		//给首末元素赋值
		yangHui[i][0]=yangHui[i][i]=1;
		
		//给非首末元素赋值
		for(int j=1;j<yangHui[i].length-1 && i>1;++j) {
			yangHui[i][j]=yangHui[i-1][j-1]+yangHui[i-1][j];
		}
	}
	//遍历二维数组
	for(int i=0;i<yangHui.length;++i) {
		for(int j=0;j<yangHui[i].length;++j) {
			System.out.print(yangHui[i][j]+" ");
		}
		System.out.println();
	}
```

### 3.回旋矩阵

```java
	int n=7;
	int[][] array=new int[n][n];
	int count=0;
	int maxX=n-1;
	int maxY=n-1;
	int minX=0;
	int minY=0;
	while(minX<=maxX) {
	for(int x=minX;x<=maxX;x++) {
		array[minY][x]=++count;
	}
	minY++;
	for(int y=minY;y<=maxY;++y) {
		array[y][maxX]=++count;
	}
	maxX--;
	for(int x=maxX;x>=minX;--x) {
		array[maxY][x]=++count;
	}
	maxY--;
	for(int y=maxY;y>=minY;y--) {
		array[y][minX]=++count;
	}
	minX++;
}
 	
for(int i=0;i<array.length;++i) {
 		for(int j=0;j<array[i].length;++j) {
 			System.out.printf("%02d ",array[i][j]);
 		}
 		System.out.println();
 	}


```

## 排序

### **1.冒泡顺序算法（小优化）**

```java
public static void bubble_sort(int array[]) {
    	for(int i=0;i<array.length-1;++i) {
    		boolean flg=false;
    		for(int j=0;j<array.length-1-i;++j) {			
             
             if(array[j]>array[j+1]) {
				int t=array[j];
				array[j]=array[j+1];
				array[j+1]=t;
				flg=true;
			}
		}
		if(flg==false) {
			return;
		}
	}
}
```

## 查找

### **1.简单查找**(线性查找)

```java
public static int easySearch(int[] arrays,int value){
    for (int i = 0; i < arrays.length; i++) {
        if(value == arrays[i]) return i;
    }
    return -1;
}
```

### **2.二分查找**

```java
 public static int searchBin(int[] arrays, int value) {
	        int low = 0;
	        int high = arrays.length-1;
	        int mid;
	        while (low < high) {
	            mid =(high+low)/2;
	            if (value == arrays[mid]) {
	                return mid;
	            } else if (value < arrays[mid]) {
	                high = mid - 1;
	            } else {
	                low = mid + 1;
	            }
	        }
	        return -1;
	    }
```

### 3.两数之和

```java
//前提：数组有序
public static int[] twoSum(int[] arrays,int target){
    int left = 0,right = arrays.length - 1;
    int sum;
    while(left < right){
        sum = arrays[left] + arrays[right];
        if(sum == target)break;
        if(sum < target) ++left;
        else --right;
    }
    return new int[]{left + 1,right + 1};
}
```

## 数组操作

### **1.数组随机赋值且不重复**

```java
int array[]=new int[6];
		for(int i=0;i<array.length;++i) {
			array[i]=new Random().nextInt(30);
			for(int j=0;j<i;++j) {
				if(array[i]==array[j]) {
					i--;
					break;
				}
			}
		}
		for(int i=0;i<array.length;++i) {
			System.out.print(array[i]+" ");
		}
```



## 字符串操作

### 1.指定位置反转

```java
public static String reverse(String str,int startIndex,int endIndex){
    char[] chars = str.toCharArray();
    for(int x = startIndex,y = endIndex ; x < y ; x++,y --){
        char temp = chars[x];
        chars[x] = chars[y];
        chars[y] = temp;
    }
    return new String(chars);
}
```

### 2.获取子串出现次数

```java
    public static int getCount(String mainString , String subString){
        int mainLength = mainString.length();
        int subLength = subString.length();
        int count = 0;
        int index = 0;
        if(mainLength >= subLength) {
            while ((index = mainString.indexOf(subString,index)) != -1) {
                count++;
                index +=subLength;
            }
        }
        return count;
    }
}
```

### 3.最大子串

```java
public static String getMaxSameString(String str1,String str2){
    if(str1 != null && str2 != null){
        String maxStr = (str1.length() >= str2.length()) ? str1 : str2;
        String minStr = (str1.length() < str2.length()) ? str1 : str2;
        int length = minStr.length();
        for (int i = 0; i < length; i++) {
            for (int x = 0,y = length - i; y <= length; x++,y++) {
                String subStr = minStr.substring(x,y);
                if(maxStr.contains(subStr)){
                    return subStr;
                }
            }
        }
    }
    return null;

```
