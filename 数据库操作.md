



# 数据库操作

`mysql -uroot -p929957466`

`show databases;`

`use dbtest1;`

`create database dbtest1;`

`create table employees(id int,name varchar(15));`

**SQL的分类**

- DDL:数据定义语言。 CREATE \ ALTER \ DROP \ RENAME \ TRUNCATE \ 

  `DDL的操作一旦执行，不可回滚。`

- DML:数据操作语言。INSERT \ DELETE \ UPDATE \ SELECT \ 

  `DML的操作默认情况，一旦执行，也是不可回滚。但是，如果在执行DML前，执行了SET autocommit=FALSE（对DDL失效），则执行的DML操作就可以实现回滚`

- DCL:数据控制语言。COMMIT \ ROLLBACK \ SAVEPOINT \GRANT \ REMOVE \

# DML

## 查找

```mysql
SELECT * FROM employees; 
```

**查询表中所有信息，*：表中的所有字段（或列）。**



```mysql
SELECT last_name,first_name AS lname,salary 
FROM employees;
```

**列的别名 AS全称：alias（别名），可以省略。列的别名可以用一对""引起来，不要使用 ''。**



```mysql
SELECT DISTINCT department_id 
FROM employees;
```

**去除重复行 关键字：DISTINCT。**



```mysql
SELECT employee_id,salary "月工资", salary *(1+IFNULL(commission_pct,0)) * 12  "年工资" FROM employees;
```

**空值参与运算，将null替换成0，函数：IFNULL。**



**显示表结构**

```mysql
DESCRIBE employees;
```

**显示表中字段的详细信息，关键字： DESCRIBE 或 DESC 。**



**过滤数据**

```mysql
SELECT * FROM employees
WHERE department_id=90;
```

**过滤条件，声明在FROM的后面，关键字：WHERE。**



**比较运算符**

**<=> `安全等于，用于与NULL比较`。**

LEAST  比较最小值   GREATEST  比较最大值



```mysql
SELECT employee_id,last_name,salary 
FROM employees 
WHERE salary BETWEEN 6000 AND 8000;
```

**查询区间，关键字：BETWEEN...AND（闭区间）。**



```mysql
SELECT last_name,employee_id,department_id 
FROM employees 
WHERE department_id IN(10,20,30);  
```

**查询在不在此集合内，函数：IN（）。**



```mysql
SELECT last_name 
FROM employees 
WHERE last_name LIKE '%a%';
```

**模糊查找，关键字：like，%代表不确定个数的字符，去掉第一个%则表示查找以a开头的字符，去掉最后一个%同理。**



```mysql
SELECT last_name 
FROM employees  
WHERE last_name LIKE '_a%'; 
```

**查询第二个单词是a的操作，_代表一个不确定的字符。**



```mysql
SELECT 'hello' REGEXP '^he','World' RLIKE 'ld$' FROM DUAL;
```

**正则表达式匹配字符串，^表示匹配以该字符后面的字符开头的字符串，$匹配以该字符前面的字符结尾的字符串，[...]表示匹配在方括号内的任何字符，如：[abc]表示匹配a或b或c，[a-z]表示匹配任何字母，[0-9]表示匹配任何数字’，关键字：REGEXP ，RLIKE。**



**逻辑运算符**

- ###### AND 或 &&表示与


- ###### OR 或 ||表示或


- ###### NOT 或  ! 表示非


**注意：OR可以和AND一起使用，但是要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再对OR中的操作数进行操作   赋值运算符(=)的优先级最低，使用“（）”括起来的表达式优先级最高。**



## 排序与分页

**注：如果没有使用排序操作，默认情况下查询返回的数据是按照添加数据的顺序显示的。**

```mysql
SELECT employee_id,last_name,salary 
FROM employees 
ORDER BY salary DESC;
```

**使用ORDER BY对查询到的数据进行排序操作，升序（从低到高）：ASC(ascend)，降序（从高到低）：DESC(descend)。注：如果ORDER BY后没有显示指明排序的方式的话，默认按照升序排列。**



```mysql
SELECT last_name,employee_id,salary * 12 annual_sal
FROM employees
ORDER BY annual_sal;
```

**列的别名只能在ORDER BY中使用，不能在WHERE中使用；WHERE需要声明在FROM之后，ORDER BY之前**



```mysql
SELECT employee_id,salary,department_id
FROM employees
ORDER BY department_id DESC,salary ASC;
```

**二级排序，即在department_id的排序下进行salary的排序**



```mysql
SELECT department_id,last_name
FROM employees
LIMIT 0,20;
```

****

**分页查询,关键字：LIMIT，LIMIT后第一个数字为偏移量，第二个数字为显示的行数，LIMIT格式：严格来说：LIMIT 位置偏移量，条目数；结构“LIMIT 0，条目数”  等价于  “LIMIT 条目数”**



## 多表查询

```mysql
SELECT employee_id,department_name
FROM employees,departments
WHERE employees.department_id = departments.department_id;
```

**多表查询：需要有连接条件**



```mysql
SELECT emp.employee_id,dep.department_name,emp.department_id
FROM employees emp,departments dep
WHERE emp.department_id = dep.department_id;
```

**给表起别名，在SELECT和WHERE中使用表的别名；注：如果有n个表实现多表查询，则至少需要n-1个连接条件**



```mysql
SELECT emp.last_name,emp.employee_id,man.last_name,man.employee_id
FROM employees emp,employees man
WHERE emp.manager_id=man.employee_id;
```

**自连接**



### 多表查询的分类

- 角度一：等值连接   vs   非等值连接
- 角度二：自连接       vs   非自连接
- 角度三：内连接       vs   外连接 

**外连接的分类：左外连接，右外连接，满外连接**

```mysql
SELECT emp.last_name,emp.employee_id,man.last_name,man.employee_id
FROM employees emp INNER JOIN employees man
ON emp.manager_id=man.employee_id;
```

**SQL99语法实现内连接，关键字：INNER ，JOIN...ON...**，



```mysql
SELECT emp.last_name,emp.employee_id,man.last_name,man.employee_id
FROM employees emp  LEFT OUTER JOIN employees man
ON emp.manager_id=man.employee_id;
```

**SQL99语法实现左外连接，关键字：OUTER，JOIN...ON...**



### 七种JOIN的实现

#### **1.内连接**

```mysql
SELECT emp.employee_id,emp.last_name,dep.department_name
FROM employees emp JOIN departments dep
ON emp.department_id=dep.department_id;
```



#### **2.左外连接**

```mysql
SELECT emp.employee_id,emp.last_name,dep.department_name
FROM employees emp LEFT JOIN departments dep
ON emp.department_id=dep.department_id;
```



#### **3.右外连接**

```mysql
SELECT emp.employee_id,emp.last_name,dep.department_name
FROM employees emp RIGHT JOIN departments dep
ON emp.department_id=dep.department_id;
```



**4.左左外连接**

```mysql
SELECT emp.employee_id,dep.department_name
FROM employees emp LEFT JOIN departments dep
ON emp.department_id=dep.department_id
WHERE dep.department_id IS NULL;
```



**5.右右外连接**

```mysql
SELECT emp.employee_id,dep.department_name
FROM employees emp RIGHT JOIN departments dep
ON emp.department_id=dep.department_id
WHERE emp.department_id IS NULL;
```



**6.满外连接**

```mysql
SELECT emp.employee_id,dep.department_name
FROM employees emp LEFT JOIN departments dep
ON emp.department_id=dep.department_id
UNION ALL
SELECT emp.employee_id,dep.department_name
FROM employees emp RIGHT JOIN departments dep
ON emp.department_id=dep.department_id
WHERE emp.department_id IS NULL;
```



**7.缺中连接**

```mysql
SELECT emp.employee_id,dep.department_name
FROM employees emp LEFT JOIN departments dep
ON emp.department_id=dep.department_id
WHERE dep.department_id IS NULL
UNION ALL
SELECT emp.employee_id,dep.department_name
FROM employees emp RIGHT JOIN departments dep
ON emp.department_id=dep.department_id
WHERE emp.department_id IS NULL;
```

#### **SQL99新特性**

##### SQL99新特性1：自然连接

```mysql
SELECT employee_id,last_name,department_name
FROM employees e JOIN departments d
ON e.department_id = d.department_id
AND e.manager_id = d.manager_id;

SELECT employee_id,last_name,department_name
FROM employees e  NATURAL JOIN departments d;
```

**NATURAL  JOIN：自动查询两张表中所有相同的字段，然后进行等值连接**



##### **SQL99 新特性2： USING**

```mysql
SELECT employee_id,last_name,department_name
FROM employees e JOIN departments d
USING(department_id);
#ON e.department_id = d.department_id
```

**使用JOIN USING 简化 JOIN ON的等值连接**



## 单行函数

### 流程控制函数

| 函数                                                       | 用法                                            |
| ---------------------------------------------------------- | ----------------------------------------------- |
| IF(value,value1,value2)                                    | 如果value的值为true，返回value1，否则返回value2 |
| IFNULL(value1,value2)                                      | 如果value1不为null，返回value1，否则返回value2  |
| CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 ...END    | 相当于java的if...else if...else...              |
| CASE expr(变量) WHEN 常量值1 THEN 常量值1 THEN 值2 ... END | 相当于Java的switch...case...                    |

```mysql
SELECT last_name,salary,
             CASE WHEN salary >= 15000 THEN '富哥'
             WHEN salary >= 10000 THEN '老表'
             ELSE '666' END
 FROM employees;
 #实例
```



## 聚合函数

### 常见的聚合函数

1 AVG / SUM ：只适用于数值类型的字段（或变量）

```mysql
SELECT AVG(salary),SUM(salary)
FROM employees;
#示例
```

2 MAX / MIN ：适用于数值类型，字符串类型和日期时间类型的字段（或变量）

```mysql
SELECT MAX(salary),MIN(salary),MAX(hire_date),MIN(hire_date)
FROM employees;
#示例
```

3 COUNT ：计算指定字段在查询结构中出现的次数（不计算空值）

```mysql
SELECT COUNT(*),COUNT(salary)
FROM employees;
#示例，COUNT(*)和COUNT(具体字段)皆可查询全部字段
```

**COUNT(*)、COUNT(1)和COUNT(具体字段)效率比较**

> 如果使用的是 MySQL  MySAM 存储引擎， 则三者效率相同，都是O(1)
>
> 如果使用的是InnoDB存储引擎， 则三者效率:COUNT(*)=COUNT(1)>COUNT(具体字段)



### GROUP BY的使用

**作用：分组** 

```mysql
SELECT department_id,AVG(salary)
FROM employees
GROUP BY department_id;
```

**查询各部门平均工资，使用关键字：GROUP BY**



```mysql
SELECT department_id,job_id,AVG(salary)
FROM employees
GROUP BY department_id,job_id;
```

**二级分组：GROUP BY带两参数，且两参数谁先谁后不改变结果。GROUP BY声明在FROM 后面，WHERE后面，ORDER BY前面，LIMIT前面**



### HAVING的使用

**作用：过滤数据**

**如果过滤条件中使用了聚合函数，则必须使用HAVING来替换WHERE，且HAVING必须声明在WHERE的后面，开发中HAVING尽量跟GROUP BY一起使用**

```mysql
SELECT department_id,MAX(salary)
FROM employees
WHERE department_id IN (10,20,30,40)
GROUP BY department_id
#HAVING MAX(salary) >10000 AND department_id IN (10,20,30,40);
#实例：查询部门id为10，20，30，40这4个部门中最高工资比10000高的部门信息
```

**推荐使用此种方式，执行效率较高**



WHERE与HAVING的对比

> 从适用范围上讲，HAVING的适用范围更广
>
> 过滤条件中没有聚合函数：WHERE的执行效率高于HAVING

##### SQL底层执行原理

SELECT语句的完整结构

**sql92语法：**

```mysql
SELECT...,...,......(存在聚合函数)
FROM...,...,...
WHERE 多表的连接条件 AND 不包含聚合函数的过滤条件
GROUP BY ...,... WITH ROLLUP#计算总数
HAVING 包含聚合函数的过滤条件
ORDER BY ...,...(ASC / DESC)
LIMIT ...,... 
```

**sql99语法：**

```mysql
SELECT...,...,......(存在聚合函数)
FROM...(LEFT / RIGHT)JOIN ...ON 多表的连接条件
WHERE 不包含聚合函数的过滤条件
GROUP BY ...,...
HAVING 包含聚合函数的过滤条件
ORDER BY ...,...(ASC / DESC)
LIMIT ...,... 
```

##### SQL语句的执行过程

```mysql
FROM -> WHERE -> GROUP BY -> HAVING -> SELECT 的字段 -> DISTINCT ->ORDER BY -> LIMIT...
```

## 子查询

问题引入：谁的工资比Abel高



方式一：

```mysql
SELECT salary
FROM employees
WHERE last_name = 'Abel';
#11000

SELECT last_name,salary
FROM employees
WHERE salary > 11000;
```



方式二：使用自连接

```mysql
SELECT e2.last_name,e2.salary
FROM employees e1,employees e2
WHERE e2.salary > e1.salary AND e1.last_name = 'Abel';
```



方式三：子查询

```mysql
SELECT last_name,salary
FROM employees
WHERE salary > (
                 SELECT salary
				 FROM employees
				 WHERE last_name = 'Abel'
);
```



称谓的规范：外查询（主查询）、内查询（子查询）

子查询的分类

> 角度一（内查询结果返回结果的条目数）：单行子查询 / 多行子查询
>
> 角度二（内查询是否被查询多次）： 相关子查询 / 非相关子查询

### 单行子查询

**单行子查询比较操作符**

| 操作符 | 含义                     |
| ------ | ------------------------ |
| =      | equal to                 |
| >      | greater than             |
| >=     | greater than or equal to |
| <      | less than                |
| <=     | less than or equal to    |
| <>     | not equal to             |

### 多行子查询

**多行子查询比较操作符**

| 操作符 | 含义                                                       |
| ------ | ---------------------------------------------------------- |
| IN     | 等于列表中的**任意一个**                                   |
| ANY    | 需要和单行比较操作符一起使用，和子查询返回的某一个值比较   |
| ALL    | 需要和单行比较操作符一起使用，和子查询返回的**所有值**比较 |
| SOME   | 实际上是ANY的别名，作用相同，一般常使用ANY                 |

## MySQL中的数据类型

| 类型             | 类型举例                                                     |
| ---------------- | ------------------------------------------------------------ |
| 整数类型         | TINYINT、SMALLINT、MEDIUMINT、**INT（或INTEGER）**、BIGINT   |
| 浮点类型         | FLOAT、DOUBLE                                                |
| 定点数类型       | **DECIMAL**                                                  |
| 位类型           | BIT                                                          |
| 日期时间类型     | YEAR、TIME、**DATE**、DATETIME、TIMESTAMP                    |
| 文本字符串类型   | CHAR、**VARCHAR**、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT      |
| 枚举类型         | ENUM                                                         |
| 集合类型         | SET                                                          |
| 二进制字符串类型 | BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB      |
| JSON类型         | JSON对象、JSON数组                                           |
| 空间数据类型     | 单值：GEOMETRY、POINT、LINESTRING、POLYGON<br>集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTTION |

常见的几类类型介绍如下：

| 数据类型      | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| INT           | 从-2^31到2^31-1的整型数据。                                  |
| CHAR(size)    | 定长字符数据，若未指定，默认为1个字符，最大长度255           |
| VARCHAR(size) | 可变长字符数据，根据字符串实际长度保存，**必须指定长度**     |
| FLOAT(M,D)    | 单精度，占用4个字节，M=整数位+小数位，D=小数位，D<=M<=255,0<=D<=30，默认M+D<=6 |
| DOUBLE(M,D)   | 双精度，占用8个字节，D<=M<=255,0<=D<=30，默认M+D<=15         |
| DECIMAL(M,D)  | 高精度小数，占用M+2个字节，D<=M<=65,0<=D<=30，最大取值范围与DOUBLE相同 |
| DATE          | 日期型数据，格式`YYYY--MM--DD`                               |
| BLOB          | 二进制形式的长文本数据，最大可达4G                           |
| TEXT          | 长文本数据，最大可达4G                                       |

常见的数据类型属性，如下：

| MySQL关键字        | 含义                     |
| ------------------ | ------------------------ |
| NULL               | 数据列可包含NULL值       |
| NOT NULL           | 数据列不允许包含NULL值   |
| DEFAULT            | 默认值                   |
| PRIMARY KEY        | 主键                     |
| AUTO_INCREMENT     | 自动递增，适用于整数类型 |
| UNSIGNED           | 无符号                   |
| CHARACTER SET name | 指定一个字符集           |

### 整数类型

整数类型一共有5种，包括TINYINT、SMALLINT、MEDIUMINT、INT（或INTEGER）、BIGINT

它们的区别如下表所示：

| 整数类型     | 字节 | 有符号数取值范围         | 无符号数取值范围 |
| ------------ | ---- | ------------------------ | ---------------- |
| TINYINT      | 1    | -128 - 127               | 0 - 255          |
| SMALLINT     | 2    | -32768 - 32767           | 0 - 65535        |
| MEDIUMINT    | 3    | -83888608 - 83888607     | 0 - 16777215     |
| INT、INTEGER | 4    | -2147483648 - 2147483647 | 0 - 4294967295   |
| BIGINT       | 8    | ...                      | ...              |

使用场景

TINYINT：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。

SMALLINT：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。

MEDIUMINT：用于较大整数的计算，比如车站每日的客流量等。

INT、INTEGER：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。

BIGINT：只有当你处理特别大的整数时才会用到，比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。

### 浮点类型

浮点数和定点数类型的特点是可以**处理小数**，你可以把整数看成小数的一个特例。因此，浮点数和定点数的使用场景，比整数大多了。MySQL支持的浮点数类型，分别是FLOAT、DOUBLE、REAL。

- FLOAT表示单精度浮点数
- DOUBLE表示双精度浮点数

**问题1**：FLOAT 和 DOUBLE 这两种数据类型的区别是什么？

FLOAT 占用字节数少（4字节），取值范围小，DOUBLE 占用字节多，取值范围大。

**问题2**：为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于有符号数取值范围大于等于零的部分呢？

MySQL 存储浮点数的格式为：符号（S）、尾数（M）和阶码（E）。因此，无论有没有符号，MySQL的浮点数都会存储表示符号的部分。因此，所谓的无符号取值范围，其实就是有符号数取值范围大于等于零的部分。

#### 精度误差说明

浮点数类型有个缺陷，就是不精准。当我们在一个表中使用 DOUBLE 插入值分别为0.47,0.44,0.19，我们期待的运行结果是0.47+0.44+0.19 = 1.1。而实际上却是1.09999...。如果使用 FLOAT ，则误差更大。

### 定点数类型

MySQL 中的定点数只有 DECIMAL 一种类型。

| 数据类型                 | 字节数  | 含义               |
| ------------------------ | ------- | ------------------ |
| DECIMAL(M,D),DEC,NUMERIC | M+2字节 | 有效范围由M和D决定 |

#### 浮点数 VS 定点数

- 浮点数相对于定点数的优点是在长度一定的情况下，浮点数类型取值范围大，但是不精准，适用于需要取值范围大，又可以忍受微小误差的科学计算场景（如计算化学、分子建模、流动力学等）
- 定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景（如设计金额计算的场景）



# 创建和管理表

## 一条数据的存储过程

**存储数据是处理数据的第一步**

```mysql
创建数据库 --> 确认字段 --> 创建数据表 --> 插入数据
```

我们要先创建一个数据库，而不是直接创建数据表呢？

因为从系统架构的层次上看， MySQL 数据库系统从大到小依次是 **数据库服务器**、**数据库**、**数据表**、数据表的**行与列**。

## 如何创建数据库

●  方式1：创建数据库

```mysql
CREATE DATABASE 数据库名;
```

●  方式2：创建数据库并指定字符集

```mysql
CREATE DATABASE 数据库名 CHARACTER SET 字符集 COLLATE 字符规则; 
```

●  方式3：判断数据库是否存在，不存在则创建数据库(**推荐**)

```mysql
CREATE DATABASE IF NOT EXISTS 数据库名;
```

> **注：DATABASE不能改名，一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删除旧库完成的。**

## 使用数据库

●  查看当前所有的数据库

```mysql
SHOW DATABASES;
```

●  查看当前正在使用的数据库

```mysql
SELECT DATABASE();
```

●  查看指定库下的所有表

```mysql
SHOW TABLES FROM 数据库名;
```

●  查看数据库的创建信息

```mysql
SHOW CREATE DATABASE 数据库名;
SHOW CREATE DATABASE 数据库名\G;#cmd
```

●  切换数据库

```mysql
USE 数据库名;
```

●  查看当前数据库下的所有表

```mysql
SHOW TABLES;
```

## 修改数据库

●  更改数据库字符集

```mysql
ALTER DATABASE 数据库名 CHARACTER SET 字符集;
```

## 删除数据库

●  方式1：删除指定的数据库

```mysql
DROP DATABASE 数据库名;
```

●  方式2：删除指定的数据库（**推荐**）

```mysql
DROP DATABASE IF EXISTS 数据库名;
```

## 创建数据表

**●   必须具备：**

>**CREATE TABLE权限**
>
>**存储空间**

**●  语法格式：**

CREATE TABLE [IF NOT EXISTS] 表名(

字段1,数据类型 [约束条件] [默认值],

字段2,数据类型 [约束条件] [默认值]

字段3,数据类型 [约束条件] [默认值],

......

[表约束条件]

);

**●  必须指定：**

> 表名
>
> 列名(或字段名)，数据类型，**长度**
>

```mysql
CREATE TABLE test
AS 
SELECT employee_id,last_name,salary
FROM employees;
```

**将查询到的数据放到一个新表中**



## 修改数据表

### 添加一个字段

●  方式一：默认添加到表的最后一个字段位置

```mysql
ALTER TABLE 数据表名
ADD 字段1 数据类型 [约束条件];
```

●  方式2：将字段添加到表的第一个字段位置

```mysql
ALTER TABLE 数据表名
ADD 字段1 数据类型 [约束条件] FIRST;
```

●  方式3：将字段添加到指定字段后

```mysql
ALTER TABLE 数据表名
ADD 字段2 数据类型 [约束条件] AFTER 字段1;
```

### 修改一个字段

可修改的字段有数据类型，长度，默认值等

●  修改字段长度

```mysql
ALTER TABLE 数据表名
MODIFY 字段1 数据类型 [约束条件];
```

●  修改默认值

```mysql
ALTER TABLE 数据表名
MODIFY 字段1 数据类型 [约束条件] DEFAULT 字段2;
```

●  重命名一个字段

```mysql
ALTER TABLE 数据表名
CHANGE 修改前的字段名 修改后的字段名 数据类型 [约束条件];
#可在修改字段名的时候同时修改类型长度
```

### 删除一个字段

```mysql
ALTER TABLE 数据表名
DROP COLUMN 字段1;
```

## 重命名数据表

●  方式1：使用RENAME

```mysql
RENAME TABLE 数据表名
TO 新的数据表名;
```

●  方式2

```mysql
ALTER TABLE 数据表名
RENAME [TO] 新的数据表名;#TO可省略
```

## 删除数据表

```mysql
DROP TABLE IF EXISTS 数据表名;
```

## 清空数据表

●  TRUNCATE TABLE语句

>删除表中所有的数据
>
>释放表的存储空间

●  语句：

```mysql
TRUNCATE TABLE 数据表名;
```

●  TRUNCATE语句**不能回滚**，而使用DELETE删除数据，可以回滚

●  TRUNCATE TABLE 与 DELETE FROM 对比

**相同点**：都可以实现对表中所有数据的删除，同时保留表结构。

**不同点**：

> TRUNCATE TABLE： 一旦执行此操作，表数据全部删除。同时，表的数据是不可以回滚的。
>
> DELETE FROM：： 一旦执行此操作，表数据可以全部删除。同时，数据是可以实现回滚的。

COMMIT 和 ROLLBACK

COMMIT：提交数据。一旦执行COMMIT，则数据永久的被保存在数据库中，意味着数据不可以回滚。

ROLLBACK：回滚数据。一旦执行ROLLBACK，则可以实现数据的回滚。回滚到最近的一次COMMIT之后。

演示：DELETE FROM

```mysql
SET autocommit=FALSE;

DELETE FROM ddltest;

SELECT * FROM ddltest;

ROLLBACK;
```

>阿里开发规范
>
>【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE 无事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句
>
>说明：TRUNCATE  TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同

## 数据处理之增删改

### 插入数据

**●  方式1： VALUES方式添加**

使用这种语法一次只能向表中插入**一条**数据

```mysql
#不指明添加的字段
INSERT INTO emp1
VALUES('00001','TOM','2001-01-01',2300);
#必须按照声明的先后顺序
```

```mysql
#指明添加的字段（推荐）
INSERT INTO emp1(`name`,id,salary,hire_date)
VALUES('Bob','00001',3400,'1988-07-24');
```

```mysql
#不设置约束，可以不给所有属性赋值，不进行赋值的属性值为null
INSERT INTO emp1(`name`,id,hire_date)
VALUES('Jod','00003','1988-07-24');
```

```mysql
INSERT INTO emp1(`name`,id,hire_date)
VALUES('蔡徐坤','00004','1988-07-24'),
('dsk','00005','1988-07-24');
#一次插入多条记录
```

**●  方式2：将查询结果添加到表中**

```mysql
INSERT INTO emp1(id,`name`,salary)
SELECT employee_id,first_name,salary
FROM employees;
```

● 注：**VALUES**也可以写成**VALUE**，但是VALUES是标准语法

### 更新数据（修改数据）

用法：UPDATE... SET ... WHERE ...

可以实现批量修改数据

**修改一个字段**

```mysql
#实例
UPDATE  emp1
SET salary = 2300
WHERE id = 5;
```

**修改多条字段**

```mysql
UPDATE emp1
SET hire_date = CURDATE(), salary = 2500
WHERE id = 3;
```

注：修改数据时，是可能存在不成功的情况的。（可能是由于约束的影响造成的）

### 删除数据

用法：DELETE FROM ... WHERE ...

```mysql
DELETE FROM emp1
WHERE id = 1;
```

注：在删除数据时，也有可能因为约束的影响，导致删除失败

### MYSQL8新特性：计算列

```mysql
CREATE TABLE test1(
a INT,
b INT,
c INT GENERATED ALWAYS AS (a+b) VIRTUAL
);
#属性c自动计算a+b的结果
```

## 约束

### 非空约束

作用：限制某个字段/某列的值不允许为空

关键字：NOT NULL

非空约束只能出现在表的对象的列上，只能某个列单独限定非空，不能组合非空。

**在CREATE TABLE 时添加约束**

```mysql
CREATE TABLE Test(
id INT NOT NULL,
last_name VARCHAR(15) NOT NULL,
email     VARCHAR(25)
);
```

**在ALTER TABLE 时添加约束**

```mysql
ALTER TABLE test1
MODIFY last_name VARCHAR(15) NOT NULL;
```

**在ALTER TABLE 时删除约束**

```mysql
ALTER TABLE test1
MODIFY last_name VARCHAR(15)  NULL;
```

### 唯一性约束

作用：用来限制某个字段/某列的值不能重复。

关键字：UNIQUE

特点：

- 同一个表可以有多个唯一约束。
- 唯一约束可以是某一个列的值唯一，也可以是多个列的组合的值唯一。
- **唯一性约束允许列值为空**。
- 在创建唯一约束时，如果不给唯一约束命名，就默认和列名相同。
- **MySQL会给唯一约束的列上默认创建一个唯一索引。**

**在 CREATE TABLE 时添加约束**

- 方式1：

```mysql
CREATE TABLE test(
id INT UNIQUE,#列级约束
last_name VARCHAR(15),
email VARCHAR(25),
salary DECIMAL(10,2),
[CONSTRAINT uk_test_email] UNIQUE(email)#表级约束
);
```

- 方式2：

```mysql
CREATE TABLE User(
  id INT,
  `name` VARCHAR(15),
  `passeord` VARCHAR(25),
   CONSTRAINT uk_user_name_pwd UNIQUE(`name`,`password`)#复合唯一
);#数据可不同时相同
```

**在 ALTER TABLE 时添加约束**

- 方式1：

```mysql
ALTER TABLE test
ADD UNIQUE(salary);
```

- 方式2：

```mysql
ALTER TABLE test
MODIFY last_name VARCHAR(15) UNIQUE;
```

**删除唯一性约束**

删除唯一性约束通过删除唯一性索引的方式实现

```mysql
ALTER TABLE test
DROP INDEX uk_test_email;
```

### 主键约束

关键字：PRIMARY KEY

特征：非空且唯一，用于唯一的标识表中的一条记录。

- 主键约束相当于**唯一约束+非空约束的组合**，主键约束列不允许重复，也不允许出现空值。
- 一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。
- 主键约束对应着表中的一列或者多列（复合主键）。

**在 CREATE TABLE 时添加约束**

```mysql
CREATE TABLE test(
id INT PRIMARY KEY,
last_name VARCHAR(15),
salary DECIMAL(10,2),
email VARCHAR(25)
);
```

**在 ALTER TABLE 时添加约束**

```mysql
ALTER TABLE test
ADD PRIMARY KEY(id);
```

**删除主键约束**

```mysql
ALTER TABLE test
DROP PRIMARY KEY;
```

### 自增列

作用：某个字段的值自增

关键字：auto_increment

特点和要求：

1. 一个表最多只能有一个自增长列
2. 当需要产生唯一标识符或顺序值时，可设置自增长
3. **自增长列约束的列必须是键列（主键列，唯一键列）**
4. 自增约束的列的数据类型必须是整数类型
5. 如果自增列指定了0和NULL，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值

使用：

**在 CREATE TABLE 时添加**

```mysql
CREATE TABLE test(
  id INT PRIMARY KEY AUTO_INCREMENT,
  last_name VARCHAR(15)
);
```

**在 ALTER TABLE 时添加**

```mysql
ALTER TABLE test
MODIFY id INT AUTO_INCREMENT;#前提是id有主键约束
```

**删除自增列**

```mysql
ALTER TABLE test
MODIFY id INT;
```

### 外键约束

作用：限定某个表的某个字段的引用完整性。

例如：员工表的员工所在的部门的选择，必须在部门表中能找到对应的部分。

关键字：FOREIGN KEY

**一个表可以建立多个外键约束**

使用：

1.先创建主表

```mysql
CREATE TABLE dept1(
  id INT PRIMARY KEY,
  dept_name VARCHAR(15)
);
```

1.再创建从表，同时添加外键约束

```mysql
CREATE TABLE emp1(
  emp_id INT PRIMARY KEY AUTO_INCREMENT,
  emp_name VARCHAR(15),
  department_id INT,
  CONSTRAINT fk_emp1_dept_id FOREIGN KEY(department_id) REFERENCES dept1(id)#关联的属性必须有主键约束
);
```

**在 ALTER TABLE 中添加外键约束**

```mysql
ALTER TABLE emp1
ADD  FOREIGN KEY(department_id) REFERENCES dept1(id);
```

### 检查约束

作用：检查某个字段的值是否符合要求，一般指的是值的范围。

关键字：CHECK

说明：MySQL 5.7 不支持CHECK约束，MySQL 8.0 支持。

**在 CREATE TABLE 中添加检查约束**

```mysql
CREATE TABLE test(
 id INT,
 last_name VARCHAR(15),
 salary DECIMAL(10,2) CHECK(salary > 2000)
);
```

### 默认值约束

作用：给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值默认值。

关键字：DEFAULT

**在 CREATE TABLE 中添加默认值约束**

```mysql
CREATE TABLE test(
id INT,
last_name VARCHAR(15),
salary DECIMAL(10,2) DEFAULT 2000
);
```

**在 ALTER TABLE 中添加默认值约束**

```mysql
ALTER TABLE test
MODIFY salaty DECIMAL(10,2) DEFAULT 2000;
```

**在 ALTER TABLE 中删除默认值约束**

```mysql
ALTER TABLE test
MODIFY salaty DECIMAL(10,2);
```

## 数据库对象

### 常见的数据库对象

| 对象                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| 表（TABLE）           | 表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录。 |
| 数据字典              | 就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看。 |
| 约束（CONSTRAINT）    | 执行数据校验的规则，用于保证数据完整性的规则。               |
| 视图（VIEW）          | 一个或者多个数据表里的数据的逻辑显示，视图并不存储数据。     |
| 索引（INDEX）         | 用于提高查询性能，相当于书的目录。                           |
| 存储过程（PROCEDURE） | 用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境。 |
| 存储函数（FUNCTION）  | 用于完成一次特定的计算，具有一个返回值。                     |
| 触发器（TRIGGER）     | 相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理。 |

### 视图

#### 视图的解释

- 视图是一种**虚拟表**，本身是**不具有数据**的，占用很少的内存空间。它是SQL中的一个重要概念。
- **视图建立在已有表的基础上**，视图赖以建立的这些表称为**基表**。
- 视图的创建和删除只影响视图本身，不影响对应的基表，但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应的发生变化，反之亦然。
- 向视图提供数据内容的语句为SELECT语句，可以将视图理解为**存储起来的SELECT语句**。
- 视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。

#### 视图的创建

##### 以表创建视图

```mysql
CREATE VIEW vu_emp1
AS
SELECT last_name,employee_id,salary
FROM emps;
```

```mysql
CREATE VIEW vu_emp2
AS
SELECT last_name lanme,employee_id emp_id,salary
#查询语句中字段的别名会作为视图中字段的名称出现
FROM emps
WHERE salary > 8000;
#两种方式
CREATE VIEW vu_emp2(lname,emp_id,salary)
AS
SELECT last_name,employee_id,salary
FROM emps
WHERE salary > 8000;
```

##### 以视图创建视图

```mysql
CREATE VIEW vu_emp3
AS
SELECT * FROM vu_emp2;
```



#### 查看视图

- 查看数据库的表对象、视图对象

```mysql
SHOW TABLES;
```

- 查看视图的结构

```mysql
DESCRIBE / DESC vu_emp3;
```

- 查看视图的属性信息

```mysql
SHOW TABLE STATUS LIKE 'vu_emp3';
```

- 查看视图的详细定义信息

```mysql
SHOW CREATE VIEW vu_emp3;
```

## 存储过程与函数

一、无参数无返回值

创建存储过程

```mysql
DELIMITER %
CREATE PROCEDURE select_all_data()
BEGIN 
		SELECT * FROM employees;
END %
```

存储过程的调用

```mysql
CALL select_all_data();
```

二、带OUT参数

```mysql
DELIMITER %
CREATE PROCEDURE show_min_salary(OUT ms DOUBLE)
BEGIN
	SELECT MIN(salary) INTO ms
	FROM employees;
END %
```

调用

```mysql
CALL show_min_salary(@ms);
SELECT @ms;
```

三、带IN参数

```mysql
DELIMITER %
CREATE PROCEDURE show_someone_salary(IN empname VARCHAR(20))
BEGIN		
		SELECT salary
		FROM employees
		WHERE first_name = empname;
END %;
```

调用

```mysql
CALL show_someone_salary('Kochhar');#方式1

SET @empname = 'King';#方式2
CALL show_someone_salary(@empname);
```

四、带IN和OUT参数

```mysql
DELIMITER %
CREATE PROCEDURE show_someone_salary2(IN empname VARCHAR(20),OUT empsalary DOUBLE)
BEGIN
		SELECT salary INTO empsalary
		FROM employees
		WHERE last_name = empname;
END %;
```

调用

```mysql
CALL show_someone_salary2('Abel',@empsalary);
SELECT @empsalary;
```

五、带INOUT的参数

```mysql
DELIMITER %
CREATE PROCEDURE show_mgr_name(INOUT empname VARCHAR(20))
BEGIN 
	SELECT last_name INTO empname
	FROM employees
	WHERE employee_id=(
								SELECT manager_id
								FROM employees
								WHERE last_name = empname
										);
END %;
```

调用

```mysql
SET @empname = 'Abel';
CALL show_mgr_name(@empname);
SELECT @empname;
```

删除存储过程

```mysql
DROP PROCEDURE IF EXISTS beauty_limit;
```



### 存储函数

函数的创建

```mysql
DELIMITER $
CREATE FUNCTION email_by_name()
RETURNS VARCHAR(25)
DETERMINISTIC
CONTAINS SQL
BEGIN
		RETURN(SELECT email FROM employees WHERE last_name = 'Abel');
END $;
```

函数调用

```mysql
SELECT email_by_name();
```

对比存储函数和存储过程

|          | 关键字    | 调用语法        | 返回值            | 应用场景                         |
| -------- | --------- | --------------- | ----------------- | -------------------------------- |
| 存储过程 | PROCEDURE | CALL 存储过程() | 理解为有0个或多个 | 一般用于更新                     |
| 存储函数 | FUNCTION  | SELECT 函数()   | 只能是一个        | 一般用于查询结果为一个值并返回时 |

## 触发器

触发器的创建

```mysql
DELIMITER %
CREATE TRIGGER before_insert_test_tri
BEFORE INSERT ON test_trigger
FOR EACH ROW 
BEGIN
		INSERT INTO test_trigger_log(t_note)
		VALUES('before insert...');
END %

DELIMITER;
```

触发器的删除

```mysql
DROP TRIGGER before_insert_test_tri;
```

触发器的查看

方式1：查看当前数据库的所有触发器的定义

```mysql
SHOW TRIGGERS;
```


方式2：查看当前数据库中某个触发器的定义

```mysql
SHOW CREATE TRIGGER 触发器名;
```

方式3：从系统库information_schema的TRIGGERS表中查询“salary_check._trigger”触发器的信息。

```mysql
SELECT * FROM information_schema.TRIGGERS;
```

